/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.nifi.JWTServer;

import io.jsonwebtoken.*;
import io.jsonwebtoken.security.Keys;
import org.apache.nifi.annotation.documentation.CapabilityDescription;
import org.apache.nifi.annotation.documentation.SeeAlso;
import org.apache.nifi.annotation.documentation.Tags;
import org.apache.nifi.annotation.lifecycle.OnDisabled;
import org.apache.nifi.annotation.lifecycle.OnEnabled;
import org.apache.nifi.components.AllowableValue;
import org.apache.nifi.components.PropertyDescriptor;
import org.apache.nifi.components.ValidationContext;
import org.apache.nifi.components.ValidationResult;
import org.apache.nifi.controller.AbstractControllerService;
import org.apache.nifi.controller.ConfigurationContext;
import org.apache.nifi.processor.util.StandardValidators;
import org.apache.nifi.reporting.InitializationException;

import javax.crypto.SecretKey;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.StringReader;
import java.security.*;
import java.security.SignatureException;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.X509EncodedKeySpec;
import java.util.*;
import java.util.concurrent.atomic.AtomicReference;

@Tags({"JWT", "token", "Auth", "JSON", "web", ""})
@SeeAlso(classNames = {
        "org.apache.nifi.processors.standard.GenerateJWT",
        "org.apache.nifi.processors.standard.VerifyJWT"
})
@CapabilityDescription("Provides the ability to generate and verify JWTs. Generates a new JWT and signs it using provided" +
        " signing algorithm and signing secret. Verifies the JWT which are generated by itself for it's validity, signing algorithm and secret.")
public class JWTSigningService extends AbstractControllerService implements JWTService {
    private static final String HS256 = SignatureAlgorithm.HS256.getValue();
    private static final String HS384 = SignatureAlgorithm.HS384.getValue();
    private static final String HS512 = SignatureAlgorithm.HS512.getValue();
    private static final String RS256 = SignatureAlgorithm.RS256.getValue();
    private static final String RS384 = SignatureAlgorithm.RS384.getValue();
    private static final String RS512 = SignatureAlgorithm.RS512.getValue();
    
    public static final AllowableValue VALUE_HS256 = new AllowableValue(HS256, HS256, "HMAC using SHA-256");
    public static final AllowableValue VALUE_HS384 = new AllowableValue(HS384, HS384, "HMAC using SHA-384");
    public static final AllowableValue VALUE_HS512 = new AllowableValue(HS512, HS512, "HMAC using SHA-512");
    public static final AllowableValue VALUE_RS256 = new AllowableValue(RS256, RS256, "RSASSA-PKCS-v1_5 using SHA-256");
    public static final AllowableValue VALUE_RS384 = new AllowableValue(RS384, RS384, "RSASSA-PKCS-v1_5 using SHA-384");
    public static final AllowableValue VALUE_RS512 = new AllowableValue(RS512, RS512, "RSASSA-PKCS-v1_5 using SHA-512");

    public static final AllowableValue KEY_PROVIDER_GENERATE = new AllowableValue("GENERATE", "Generate and use keys.", "Use this property to use secure keys, generated by this controller service.");
    public static final AllowableValue KEY_PROVIDER_REFER = new AllowableValue("REFER", "Use provided values.", "Use this property to use secure keys, provided as properties to this controller service.");

    private final AtomicReference<SecretKey> shaKeyAtomicReference = new AtomicReference<>();
    private final AtomicReference<KeyPair> secretKeyPairAtomicReference = new AtomicReference<>();
    private SignatureAlgorithm signingAlgo = null;
    
    public static final PropertyDescriptor PROP_SIGNING_ALGO = new PropertyDescriptor
            .Builder().name("SIGNING_ALGO")
            .displayName("JWT Signing Algorithm")
            .description("Signing algorithm for generating and verifying JWTs.")
            .allowableValues(VALUE_HS256, VALUE_HS384, VALUE_HS512, VALUE_RS256, VALUE_RS384, VALUE_RS512)
            .defaultValue(VALUE_HS256.getValue())
            .required(true)
            .addValidator(StandardValidators.NON_EMPTY_VALIDATOR)
            .build();
    public static final PropertyDescriptor PROP_GEN_SECURE_KEY = new PropertyDescriptor
            .Builder().name("PROP_GEN_SECURE_KEY")
            .displayName("Key Provider")
            .allowableValues(KEY_PROVIDER_GENERATE, KEY_PROVIDER_REFER)
            .defaultValue(KEY_PROVIDER_GENERATE.getValue())
            .addValidator(StandardValidators.NON_EMPTY_VALIDATOR)
            .required(false)
            .build();
    public static final PropertyDescriptor PROP_SIGNING_SECRET = new PropertyDescriptor
            .Builder().name("SIGNING_SECRET")
            .displayName("Signing secret.")
            .description("")
            .sensitive(true)
            .required(false)
            .addValidator(StandardValidators.NON_EMPTY_VALIDATOR)
            .build();
    public static final PropertyDescriptor PROP_PVT_KEY = new PropertyDescriptor
            .Builder().name("PROP_PVT_KEY")
            .displayName("Private Key")
            .description("Private Key for use with JWT ECDSA or RSA algorithms. Used in signing the JWT")
            .sensitive(true)
            .required(false)
            .addValidator(StandardValidators.NON_EMPTY_VALIDATOR)
            .build();
    public static final PropertyDescriptor PROP_PUB_KEY = new PropertyDescriptor
            .Builder().name("PROP_PUB_KEY")
            .displayName("Public Key")
            .description("Public Key for use with JWT ECDSA or RSA algorithms. Used in verifying the JWT")
            .sensitive(true)
            .required(false)
            .addValidator(StandardValidators.NON_EMPTY_VALIDATOR)
            .build();

    private static final List<PropertyDescriptor> properties;

    static {
        final List<PropertyDescriptor> props = new ArrayList<>();
        props.add(PROP_SIGNING_ALGO);
        props.add(PROP_GEN_SECURE_KEY);
        props.add(PROP_SIGNING_SECRET);
        props.add(PROP_PVT_KEY);
        props.add(PROP_PUB_KEY);
        properties = Collections.unmodifiableList(props);
    }

    @Override
    protected Collection<ValidationResult> customValidate(ValidationContext validationContext) {
        final List<ValidationResult> results = new ArrayList<>();
        final String keyProviderMethod = validationContext.getProperty(PROP_GEN_SECURE_KEY).getValue();
        boolean isGenerate = keyProviderMethod.contentEquals(KEY_PROVIDER_GENERATE.getValue());

        boolean secretSet = validationContext.getProperty(PROP_SIGNING_SECRET).isSet();
        boolean pvtKeySet = validationContext.getProperty(PROP_PVT_KEY).isSet();
        boolean pubKeySet = validationContext.getProperty(PROP_PUB_KEY).isSet();

        if (isGenerate && secretSet && pvtKeySet && pubKeySet) {
            results.add(new ValidationResult.Builder()
                    .subject(keyProviderMethod)
                    .valid(false)
                    .explanation("If property " + PROP_GEN_SECURE_KEY.getDisplayName() + " is set to " +
                            KEY_PROVIDER_GENERATE.getDisplayName() +
                            ", none of Siging Secret, Private Key, Public Key must be provided.")
                    .build());
        } else if (!isGenerate && (!secretSet && !pvtKeySet && !pubKeySet)) {
            results.add(new ValidationResult.Builder()
                    .subject("Config Provider")
                    .valid(false)
                    .explanation("If property " + PROP_GEN_SECURE_KEY.getDisplayName() + " is set to " +
                            KEY_PROVIDER_REFER.getDisplayName() +
                            ", all of Siging Secret, Private Key, Public Key must be provided.")
                    .build());
        }
        return results;
    }

    @Override
    protected List<PropertyDescriptor> getSupportedPropertyDescriptors() {
        return properties;
    }

    private String checkAndRemovePrivateKeyHeader(String keyFileString) {
        String retVal = keyFileString;
        if (keyFileString.contains("-----BEGIN PRIVATE KEY-----"))
            retVal = retVal.replace("-----BEGIN PRIVATE KEY-----", "");
        if (keyFileString.contains("-----END PRIVATE KEY-----"))
            retVal = retVal.replace("-----END PRIVATE KEY-----", "");
        return retVal;
    }

    private String checkAndRemovePublicKeyHeader(String keyFileString) {
        String retVal = keyFileString;
        if (keyFileString.contains("-----BEGIN PUBLIC KEY-----"))
            retVal = retVal.replace("-----BEGIN PUBLIC KEY-----", "");
        if (keyFileString.contains("-----END PUBLIC KEY-----"))
            retVal = retVal.replace("-----END PUBLIC KEY-----", "");
        return retVal;
    }

    private String removeSpaces(String str) {
        return str.replaceAll("\\s+", "");
    }
    
    private String formatKeyString(String keyString) throws IOException {
    	StringBuilder keyLines = new StringBuilder();
        BufferedReader rdr = new BufferedReader(new StringReader(keyString));
        String line;
        while ((line = rdr.readLine()) != null) {
            keyLines.append(line);
        }
        rdr.close();
        return keyLines.toString();
    }
    
    private PrivateKey readPrivateKey(String key) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException {
        String keyString = formatKeyString(key);
        keyString = checkAndRemovePrivateKeyHeader(keyString);
        keyString = removeSpaces(keyString);
        
        byte[] pkcs8EncodedBytes = Base64.getDecoder().decode(keyString.getBytes());
        PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(pkcs8EncodedBytes);
        return KeyFactory.getInstance("RSA").generatePrivate(keySpec);
    }

    private PublicKey readPublicKey(String key) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException {
    	String keyString = formatKeyString(key);
        keyString = checkAndRemovePublicKeyHeader(keyString);
        keyString = removeSpaces(keyString);

        byte[] pkcs8EncodedBytes = Base64.getDecoder().decode(keyString);
        X509EncodedKeySpec keySpec = new X509EncodedKeySpec(pkcs8EncodedBytes);
        return KeyFactory.getInstance("RSA").generatePublic(keySpec);
    }
    
    private SignatureAlgorithm getSignatureAlgo(String signingAlgo) {
        switch (signingAlgo) {
            case "HS256":
                return SignatureAlgorithm.HS256;
            case "HS384":
                return SignatureAlgorithm.HS384;
            case "HS512":
                return SignatureAlgorithm.HS512;
            case "RS256":
                return SignatureAlgorithm.RS256;
            case "RS384":
                return SignatureAlgorithm.RS384;
            case "RS512":
                return SignatureAlgorithm.RS512;
            default:
            	return null;
        }
    }

    /**
     * @param context the configuration context
     * @throws InitializationException if unable to create a database connection
     */
    @OnEnabled
    public void onEnabled(final ConfigurationContext context) throws InitializationException, IOException, NoSuchAlgorithmException, InvalidKeySpecException {
    	boolean isGenerate = context.getProperty(PROP_GEN_SECURE_KEY).getValue().contentEquals(KEY_PROVIDER_GENERATE.getValue());
        signingAlgo = getSignatureAlgo(context.getProperty(PROP_SIGNING_ALGO).getValue());
        if (isGenerate && signingAlgo != null) {
            if (signingAlgo.getValue().contains("HS")) shaKeyAtomicReference.set(Keys.secretKeyFor(signingAlgo));
            else secretKeyPairAtomicReference.set(Keys.keyPairFor(signingAlgo));
        } else {
            if (context.getProperty(PROP_SIGNING_ALGO).getValue().contains("HS")) {
                final String secretStr = context.getProperty(PROP_SIGNING_SECRET).getValue();
                shaKeyAtomicReference.set(Keys.hmacShaKeyFor(secretStr.getBytes()));
            } else if (context.getProperty(PROP_SIGNING_ALGO).getValue().contains("RS")) {
                final String privateKeyStr = context.getProperty(PROP_PVT_KEY).getValue();
                final String publicKeyStr = context.getProperty(PROP_PUB_KEY).getValue();
                final PrivateKey privateKey = readPrivateKey(privateKeyStr);
                final PublicKey publicKey = readPublicKey(publicKeyStr);
                KeyPair keyPair = new KeyPair(publicKey, privateKey);
                secretKeyPairAtomicReference.set(keyPair);
            }
        }
    }

    @OnDisabled
    public void shutdown() {
    }

    @Override
    public JwtBuilder signJWT(JwtBuilder jwtBuilder) {
        if (signingAlgo.getValue().contains("HS")) {
            return jwtBuilder.signWith(shaKeyAtomicReference.get());
        }
        return jwtBuilder.signWith(secretKeyPairAtomicReference.get().getPrivate());
    }

    @Override
    public boolean verifyJWT(String token) throws SignatureException {
        Jws<Claims> jws = null;
        jws = (signingAlgo.getValue().contains("HS")) ? Jwts.parserBuilder().setSigningKey(shaKeyAtomicReference.get()).build().parseClaimsJws(token) : Jwts.parserBuilder().setSigningKey(secretKeyPairAtomicReference.get().getPublic()).build().parseClaimsJws(token);
        return jws != null;
    }
}
