/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.nifi.JWTServer;

import java.security.KeyPair;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.concurrent.atomic.AtomicReference;

import com.fasterxml.jackson.databind.annotation.JsonAppend;
import io.jsonwebtoken.SignatureAlgorithm;
import io.jsonwebtoken.security.Keys;
import org.apache.nifi.annotation.documentation.CapabilityDescription;
import org.apache.nifi.annotation.documentation.SeeAlso;
import org.apache.nifi.annotation.documentation.Tags;
import org.apache.nifi.annotation.lifecycle.OnDisabled;
import org.apache.nifi.annotation.lifecycle.OnEnabled;
import org.apache.nifi.components.AllowableValue;
import org.apache.nifi.components.PropertyDescriptor;
import org.apache.nifi.components.ValidationContext;
import org.apache.nifi.components.ValidationResult;
import org.apache.nifi.controller.AbstractControllerService;
import org.apache.nifi.controller.ConfigurationContext;
import org.apache.nifi.processor.exception.ProcessException;
import org.apache.nifi.processor.util.StandardValidators;
import org.apache.nifi.reporting.InitializationException;

import javax.crypto.SecretKey;

@Tags({ "JWT", "token", "Auth", "JSON", "web", ""})
@SeeAlso(classNames = {
        "org.apache.nifi.processors.standard.GenerateJWT",
        "org.apache.nifi.processors.standard.VerifyJWT"
})
@CapabilityDescription("Provides the ability to generate and verify JWTs. Generates a new JWT and signs it using provided" +
        " signing algorithm and signing secret. Verifies the JWT which are generated by itself for it's validity, signing algorithm and secret.")
public class JWTServer extends AbstractControllerService implements JWTService {
    public static final AllowableValue VALUE_HS256 = new AllowableValue("HS256","HS256","HMAC using SHA-256");
    public static final AllowableValue VALUE_HS384 = new AllowableValue("HS384","HS384","HMAC using SHA-384");
    public static final AllowableValue VALUE_HS512 = new AllowableValue("HS512","HS512","HMAC using SHA-512");
    public static final AllowableValue VALUE_ES256 = new AllowableValue("ES256","ES256","ECDSA using P-256 and SHA-256");
    public static final AllowableValue VALUE_ES384 = new AllowableValue("ES384","ES384","ECDSA using P-384 and SHA-384");
    public static final AllowableValue VALUE_ES512 = new AllowableValue("ES512","ES512","ECDSA using P-512 and SHA-512");
    public static final AllowableValue VALUE_RS256 = new AllowableValue("RS256","RS256","RSASSA-PKCS-v1_5 using SHA-256");
    public static final AllowableValue VALUE_RS384 = new AllowableValue("RS384","RS384","RSASSA-PKCS-v1_5 using SHA-384");
    public static final AllowableValue VALUE_RS512 = new AllowableValue("RS512","RS512","RSASSA-PKCS-v1_5 using SHA-512");

    public static final AllowableValue KEY_PROVIDER_GENERATE = new AllowableValue("GENERATE", "Generate and use keys.", "Use this property to use secure keys, generated by this controller service.");
    public static final AllowableValue KEY_PROVIDER_REFER = new AllowableValue("REFER", "Use provided values.", "Use this property to use secure keys, provided as properties to this controller service.");

    public static final PropertyDescriptor PROP_SIGNING_ALGO = new PropertyDescriptor
            .Builder().name("SIGNING_ALGO")
            .displayName("JWT Signing Algorithm")
            .description("Signing algorithm for generating and verifying JWTs.")
            .allowableValues(VALUE_HS256, VALUE_HS384, VALUE_HS512, VALUE_ES256, VALUE_ES384, VALUE_ES512, VALUE_RS256, VALUE_RS384, VALUE_RS512)
            .defaultValue(VALUE_HS256.getValue())
            .required(true)
            .addValidator(StandardValidators.NON_EMPTY_VALIDATOR)
            .build();
    public static final PropertyDescriptor PROP_GEN_SECURE_KEY = new PropertyDescriptor
            .Builder().name("PROP_GEN_SECURE_KEY")
            .displayName("Key Provider")
            .allowableValues(KEY_PROVIDER_GENERATE, KEY_PROVIDER_REFER)
            .defaultValue(KEY_PROVIDER_GENERATE.getValue())
            .addValidator(StandardValidators.NON_EMPTY_VALIDATOR)
            .required(false)
            .build();
    public static final PropertyDescriptor PROP_SIGNING_SECRET = new PropertyDescriptor
            .Builder().name("SIGNING_SECRET")
            .displayName("Signing secret.")
            .description("")
            .sensitive(true)
            .required(false)
            .addValidator(StandardValidators.NON_EMPTY_VALIDATOR)
            .build();
    public static final PropertyDescriptor PROP_PVT_KEY = new PropertyDescriptor
            .Builder().name("PROP_PVT_KEY")
            .displayName("Private Key")
            .description("Private Key for use with JWT ECDSA or RSA algorithms. Used in signing the JWT")
            .sensitive(true)
            .required(false)
            .addValidator(StandardValidators.NON_EMPTY_VALIDATOR)
            .build();
    public static final PropertyDescriptor PROP_PUB_KEY = new PropertyDescriptor
            .Builder().name("PROP_PUB_KEY")
            .displayName("Public Key")
            .description("Public Key for use with JWT ECDSA or RSA algorithms. Used in verifying the JWT")
            .sensitive(true)
            .required(false)
            .addValidator(StandardValidators.NON_EMPTY_VALIDATOR)
            .build();

    private static final List<PropertyDescriptor> properties;

    static {
        final List<PropertyDescriptor> props = new ArrayList<>();
        props.add(PROP_SIGNING_ALGO);
        props.add(PROP_GEN_SECURE_KEY);
        props.add(PROP_SIGNING_SECRET);
        props.add(PROP_PVT_KEY);
        props.add(PROP_PUB_KEY);
        properties = Collections.unmodifiableList(props);
    }

    @Override
    protected Collection<ValidationResult> customValidate(ValidationContext validationContext) {
        final  List<ValidationResult> results = new ArrayList<>();
        final String keyProviderMethod = validationContext.getProperty(PROP_GEN_SECURE_KEY).getValue();
        boolean isGenerate = keyProviderMethod.contentEquals(KEY_PROVIDER_GENERATE.getValue());

        boolean secretSet = validationContext.getProperty(PROP_SIGNING_SECRET).isSet();
        boolean pvtKeySet = validationContext.getProperty(PROP_PVT_KEY).isSet();
        boolean pubKeySet = validationContext.getProperty(PROP_PUB_KEY).isSet();

        if(isGenerate && secretSet && pvtKeySet && pubKeySet){
            results.add(new ValidationResult.Builder()
                    .subject(keyProviderMethod)
                    .valid(false)
                    .explanation("If property "+PROP_GEN_SECURE_KEY.getDisplayName()+" is set to "+
                            KEY_PROVIDER_GENERATE.getDisplayName()+
                            ", none of Siging Secret, Private Key, Public Key must be provided.")
                    .build());
        }else if(!isGenerate && (!secretSet && !pvtKeySet && !pubKeySet)){
            results.add(new ValidationResult.Builder()
                    .subject("Config Provider")
                    .valid(false)
                    .explanation("If property "+PROP_GEN_SECURE_KEY.getDisplayName()+" is set to "+
                            KEY_PROVIDER_REFER.getDisplayName()+
                            ", all of Siging Secret, Private Key, Public Key must be provided.")
                    .build());
        }
        return results;
    }

    @Override
    protected List<PropertyDescriptor> getSupportedPropertyDescriptors() {
        return properties;
    }

    /**
     * @param context
     *            the configuration context
     * @throws InitializationException
     *             if unable to create a database connection
     */
    @OnEnabled
    public void onEnabled(final ConfigurationContext context) throws InitializationException {
        boolean isGenerate = context.getProperty(PROP_GEN_SECURE_KEY).getValue().contentEquals(KEY_PROVIDER_GENERATE.getValue());
        String signingAlgo = context.getProperty(PROP_SIGNING_ALGO).getValue();
        if(isGenerate){
            geneateKey(signingAlgo);
        }
    }
    private final AtomicReference<SecretKey> KEY = new AtomicReference<>();
    private final AtomicReference<KeyPair> secretKeyPairAtomicReference = new AtomicReference<>();
    private SignatureAlgorithm getSignatureAlgo(String signingAlgo) {
        switch (signingAlgo){
            case "HS256":
                return SignatureAlgorithm.HS256;
            case "HS384":
                return SignatureAlgorithm.HS384;
            case "HS512":
                return SignatureAlgorithm.HS512;
            case ""
        }
    }
    private void geneateKey(String signingAlgo){
        if(signingAlgo.matches("HS\\d+")){ // HMAC-SHA
            final int bitLen = Integer.parseInt(signingAlgo.substring(2));
            switch (bitLen){
                case 256:
                    KEY.set(Keys.secretKeyFor(SignatureAlgorithm.HS256));
                    break;
                case 384:
                    KEY.set(Keys.secretKeyFor(SignatureAlgorithm.HS384));
                    break;
                case 512:
                    KEY.set(Keys.secretKeyFor(SignatureAlgorithm.HS512));
                    break;
            }
        } else if(signingAlgo.matches("RS\\d+")) { // RSA or
            final int bitLen = Integer.parseInt(signingAlgo.substring(2));
            switch (bitLen){
                case 256:
                    KEY.set(Keys.secretKeyFor(SignatureAlgorithm.RS256));
                    break;
                case 384:
                    KEY.set(Keys.secretKeyFor(SignatureAlgorithm.RS384));
                    break;
                case 512:
                    KEY.set(Keys.secretKeyFor(SignatureAlgorithm.RS512));
                    break;
            }
        } else { // Elliptic Curve
            final int bitLen = Integer.parseInt(signingAlgo.substring(2));
            switch (bitLen){
                case 256:
                    KEY.set(Keys.secretKeyFor(SignatureAlgorithm.ES256));
                    break;
                case 384:
                    KEY.set(Keys.secretKeyFor(SignatureAlgorithm.ES384));
                    break;
                case 512:
                    KEY.set(Keys.secretKeyFor(SignatureAlgorithm.ES512));
                    break;
            }
        }
    }
    @OnDisabled
    public void shutdown() {

    }

    @Override
    public void execute() throws ProcessException {

    }

}
